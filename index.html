<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Debug GPS AR</title>
    <style>
      body { margin: 0; overflow: hidden; }
      video, canvas {
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        object-fit: cover;
      }
    </style>
  </head>
  <body>
    <video id="camera" autoplay playsinline muted></video>
    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js';

      let userLat = null, userLng = null, userHeading = 0;
      let targetLat = null, targetLng = null;

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 2); // í™”ë©´ ì•ìª½ìœ¼ë¡œ ë³´ê¸° ì¢‹ê²Œ ì„¤ì •

      const renderer = new THREE.WebGLRenderer({ alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const cube = new THREE.Mesh(geometry, material);
      scene.add(cube);
      cube.visible = false;

      async function startCamera() {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
        document.getElementById('camera').srcObject = stream;
      }

      function getDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3;
        const Ï†1 = lat1 * Math.PI / 180;
        const Ï†2 = lat2 * Math.PI / 180;
        const Î”Ï† = (lat2 - lat1) * Math.PI / 180;
        const Î”Î» = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(Î”Ï†/2) ** 2 + Math.cos(Ï†1) * Math.cos(Ï†2) * Math.sin(Î”Î»/2) ** 2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
      }

      function getBearing(lat1, lon1, lat2, lon2) {
        const Ï†1 = lat1 * Math.PI / 180;
        const Ï†2 = lat2 * Math.PI / 180;
        const Î»1 = lon1 * Math.PI / 180;
        const Î»2 = lon2 * Math.PI / 180;
        const y = Math.sin(Î»2 - Î»1) * Math.cos(Ï†2);
        const x = Math.cos(Ï†1) * Math.sin(Ï†2) -
                  Math.sin(Ï†1) * Math.cos(Ï†2) * Math.cos(Î»2 - Î»1);
        const Î¸ = Math.atan2(y, x);
        return (Î¸ * 180 / Math.PI + 360) % 360;
      }

      function updateCubePosition() {
        if (userLat === null || userLng === null || targetLat === null || targetLng === null) return;

        const distance = getDistance(userLat, userLng, targetLat, targetLng);
        const bearing = getBearing(userLat, userLng, targetLat, targetLng);
        const relativeBearing = bearing - userHeading;

        const angleRad = relativeBearing * Math.PI / 180;
        const x = Math.sin(angleRad) * distance * 0.05;
        const z = -Math.cos(angleRad) * distance * 0.05;

        console.log("ğŸ“ ë‚´ìœ„ì¹˜:", userLat, userLng);
        console.log("ğŸ¯ íƒ€ê²Ÿìœ„ì¹˜:", targetLat, targetLng);
        console.log("ğŸ“ ê±°ë¦¬:", distance.toFixed(2), "m, ğŸ§­ ë°©í–¥ì°¨:", relativeBearing.toFixed(2), "deg");
        console.log("ğŸ§Š íë¸Œ ìœ„ì¹˜ x:", x.toFixed(2), "z:", z.toFixed(2));

        cube.position.set(x, 0, z);
        cube.visible = distance < 30;
      }

      navigator.geolocation.getCurrentPosition((pos) => {
        userLat = pos.coords.latitude;
        userLng = pos.coords.longitude;

        const offset = 0.000009;
        targetLat = userLat + (Math.random() - 0.5) * 2 * offset;
        targetLng = userLng + (Math.random() - 0.5) * 2 * offset;

        console.log("ğŸ¯ íƒ€ê²Ÿ ì¢Œí‘œ ì´ˆê¸°í™” ì™„ë£Œ:", targetLat, targetLng);
      });

      window.addEventListener("deviceorientationabsolute", (event) => {
        if (event.absolute && event.alpha !== null) {
          userHeading = 360 - event.alpha;
        }
      }, true);

      setInterval(() => {
        navigator.geolocation.getCurrentPosition((pos) => {
          userLat = pos.coords.latitude;
          userLng = pos.coords.longitude;
        });
      }, 1500);

      function animate() {
        requestAnimationFrame(animate);
        updateCubePosition();
        renderer.render(scene, camera);
      }

      startCamera();
      animate();
    </script>
  </body>
</html>
